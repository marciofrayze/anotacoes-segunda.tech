= Clojure: Introdução à Programação Funcional =

Você está a fim de aprender Clojure e programação funcional *de graça*?? Tenho mais de uma década de experiência com desenvolvimento de software e estou criando uma série de cursos sobre Clojure e Programação Funcional. O primeiro deles já está quase pronto!

Preencha seu e-mail no formulário abaixo para eu saber que você tem interesse e irei te avisar assim que estiver disponível!

incluir_aqui_formulario_inscricao

Ficou na dúvida?? Confira abaixo o conteúdo programático só do primeiro curso que estou finalizando!

== Objetivo do primeiro módulo do curso ==

Aprender os fundamentos de programação em Clojure e os conceitos básicos do paradigma funcional.

Ao final do curso você deve ser capaz de:
- implementar programas básicos e executá-los através do REPL e dentro de sua IDE;
- construir suas próprias funções com e sem parâmetros;
- imprimir dados na tela;
- criar condicionais;
- entender o conceito básico de funções de primeira ordem;
- trabalhar com vetores e mapas;
- transformar elementos de vetores e mapas utizando _filter_, _map_ e _reduce_;
- entender como é possível desenvolver softwares usando estruturas de dados imutáveis;
- e criar testes automatizados para validar o funcionamento de suas funções.

== Parte 1: Introdução ==

Objetivos:

Conseguir implementar e executar programas básicos através do REPL/clj. Aprender a construir suas próprias funções, imprimir textos, condicionais e criar vetores utilizando o paradigma funcional e a linguagem Clojure.

[[Clojure-Introducao]]   
Objetivos:  
- Conhecer a proposta do curso, objetivos, metodologia e ferramentas.
- Conhecer um breve histórico do paradigma funcional.
  - Conhecer a origem do LISP.
  - Conhecer a origem do Cálculo Lambda.
- Conhecer a os princípios da linguagem Clojure.
- Ser capaz de instalar o Clojure, entrar no REPL (clj) e executar as primeiras linhas de código.
  - Ser capaz de realizar operações matemáticas simples através do REPL.
  - Entender a função _println_.
    - Saber utilizar a função _str_ para concatenar strings.

[[Vetores]]  
- Ser capaz de criar vetores com elementos do mesmo tipo e de tipos diferentes.
- Conseguir contar o número de elementos de um vetor.
- Conseguir incluir um elemento em um vetor.
- Conseguir remover um elemento em um vetor.
- Entender que vetores são imutáveis (persistentes).

[[Criando nossas próprias funções]]  
- Entender a estrutura da uma função (nome / parâmetros / corpo).
- Ser capaz de criar uma função sem parâmetros.
- Ser capaz de criar funções parametrizadas.
- Aprender a consultar o código fonte de outras funções através da IDE.

[[Imutabilidade]]
- Entender as diferenças filosoficas entre Programação Funcional e Programação Orientada a Objetos.
- Entender o problema da mutabilidade através de exemplos em JavaScript.
- Entender o impacto da mutabilidade em códigos executados de forma concorrente.

[[Funções puras]]
- Entender o que são funções puras e efeitos colaterais.
- Conseguir identificar funções puras e impuras.
- Compreender que funções puras podem ser executadas paralelamente de forma segura.

[[Binding de símbolos com let]]
- Aprender a fazer um _binding_ de um símbolo para um valor.
- Perceber as vantagens de um código mais limpo quando extraímos constantes e damos nomes para elas através de símbolos.

[[Condicionais]]
- Entender a estrutura do _if_.
- Aprender as diferentes formas de se fazer condicionais simples utilizando o _if_.
  - Utilizando _if_ e _else_.
  - Apenas com _if_ sem o _else_.
  - Retornando diretamente um booleano.
- Compreender que o _if_ funciona de forma similar a uma função (embora seja uma _special form_).
- Conhecer o conceito de _predicate_.
- Começar a compreender que o _nil_ pode ser visto como um _falsey_.
- Aprender a criar condicionais usando o _when_.

[[Statements versus Expressions]]
- Compreender as diferenças entre uma _conditional statement_ e uma _conditional expression_.
- Ser capaz de perceber as diferenças através de exemplos em JavaScript.
- Entender as vantagens da _conditional expression_.
- Ter noções das diferenças entre um código imperativo versus declarativo.

[[Testes Automatizados e Asserts]]
- Entender a importância de automatiazar os testes.
- Criar seus primeiros testes automatizados.
- Compreender para que servem e como utilizar os _asserts_.

[[True, False, Thuthy, Falsey]]
- Compreender a relação entre _True_, _False_ e as semelhanças e diferenças com _Thuthy_ e _Falsey_.
- Perceber porque existe o conceito de _Thuthy_ e _Falsey_ em Clojure e como podemos nos beneficiar deles.
- Ser capaz de identificar se trata-se de um _True/False_ ou um _Thuthy/Falsey_.
 
[[Mais sobre Vetores]]  
- Relembrar os conceitos de _conj_ e _pop_.
- Conseguir recuperar um elemento que está em uma determinada posição/index.
- Entender as diferenças entre utilizar a função _get_ e o nome do vetor como função.
- Entender os problemas possíveis de _IndexOutOfBoundsException_.
- Ser capaz de atribuir um valor padrão caso elemento que está sendo recuperado não exista.
- Conseguir "atualizar" um elemento de um vetor.

[[Tipos dos dados]]
- Entender que Clojure é uma linguagem Dinâmica e com inferência de tipos.
- Aprender a consultar os tipos.

== Parte 2: Utilizando uma IDE ==

Objetivos:  

Conseguir instalar e configurar a IDE IntelliJ e o plugin Curvice e conhecer os prinpais atalhos e se tornar capaz de navegar pela IDE, incluindo criar novos projetos, escrever códigos e executá-los através do REPL integrado à IDE.

[[Instalando o IntelliJ e o plugin Cursive]]
- Entender as vantagens de se utilizar uma IDE.
- Quais opções temos disponíveis de IDE/Editores.
- Instalar a IDE IntelliJ Community e o plugin Cursive.
- Criar o primeiro projeto pela IDE.
- Abrir o REPL dentro da IDE.
- Carregar as funções do arquivo que está sendo editado.
- Executar uma função dentro do REPL.

[[Atalhos do IntelliJ e Cursive]]
- Ser capaz de executar através de atalhos do teclado os comandos que vamos usar com mais frequencia. 
- Entender pra que serve o _Structural edit_ (também conhecido como _paredit_).
- Aprender a desabilitar o _Structurla edit_ quando necessário.

== Parte 3: Namespaces, símbolos e funções privadas ==

Objetivos:

Começar a compreender a importância de estruturar o código, separando as funções em arquivos e _namespaces_ diferentes.

[[O que é e como definir um namespace]]
- Entender a importância de separarmos nossas funções em _namespaces_ diferentes.
- Ser capaz de definir um _namespace_.
- Conhecer o tipo _Symbol_.
- Entender as diferenças entre os tipos _Symbol_ e _Keyword_.
- Conseguir importar uma funções de um outro _namespace_.
- Conseguir mudar de _namespace_ no REPL dentro da IDE.

== Parte 4: Higher order functions ==

Objetivos:

Começar a ter contato com funções de primeira ordem: entender o que são e como criá-las e a sua importância no desenvolvimento de software utilizando o paradigma funcional.

- Compreender que é possível passar a referência de uma função como parâmetro de outra função.
- Entender as vantagens e desvantagens das funções anônimas.
- Aprender a criar funções anônimas (lambda):
  - usando o _fn_.
  - usando # e %, %1, %2...

== Parte 5: Map, Filter, Reduce ==

Objetivos:

Ter os primeiros contatos com 3 funções fundamentais para o desenvolvimento de software no paradigma funcional: _map_, _filter_ e _reduce_.

- Compreender que na programação funcional trabalhamos com o conceito de transformação.
- Conseguir perceber as vantagens de solucionar problemas de forma menos imperativa.
- Entender a diferença entre um laço explícito e um implícito.
- Conseguir filtrar os elementos de um vetor de acordo com um predicado.
- Ser capaz de transformar (reduzir) todos os elementos de um vetor em um único dado.
- Conseguir mesclar o uso de maps, filters e reduce.

== Parte 6: Mapas ==

Objetivos:

Conhecer e saber como e quando utilizar uma das principais estruturas de dados do Clojure: os mapas. 

- Compreender as limitações dos vetores.
- Aprender a construir um mapa.
- Conhecer o conceito de _keyword_.
- Compreender porque é interessante usar uma _keyword_ como chave do mapa.
- Entender quando usar um vetor e quando utilizar um mapa.
- Conseguir contar a quantidade de elementos de um mapa.
- Aprender a listar as chaves e os valores de um mapa.
- Conhecer que existem outros tipos, como por exemplo o tipo ValSeq.
- Ser capaz de associar um novo valor em um mapa.
- Ser capaz de atualizar um valor de um mapa (usando _assoc_ e _update_).
- Ser capaz de remover um valor de um mapa (_dessoc_).
 
== Parte 7: Mais sobre os Mapas ==

Objetivos:

Explorar mais a fundo esta que é uma das estruturas de dados mais utilizadas durante o desenvolvimento de softwares quando estamos utilizando a linguagem Clojure.

- Compreender que mapas podem ser complexos e conter vários níveis.
- Conseguir criar e manipular mapas que contenham um vetor como valor de uma de suas chaves.
- Conseguir criar e manipular mapas que contenham um outro mapa como valor de uma de suas chaves.
- Ser capaz de recuperar um elemento do mapa usando:
  - _get_.
  - o mapa como se fosse uma função.
  - e a forma mais comum: invertendo a ordem e usando a chave como se fosse uma função.
- Entender que é perigoso usar a opção de mapa como se fosse uma função já que ela pode ser nula.
- Aprender a obter um elemento do mapa com um valor padrão caso não encontre.
- Aprender a obter um elemento do mapa com um valor padrão caso não encontre.
- Conseguir obter o valor de uma chave que está aninhada dentro de um mapa (:chave1 (:chave2 mapa)).
- Conseguir atualizar o valor de uma chave que está aninhada dentro de um mapa, utilizando _update-in_.
 
== Parte 8: Threading: uma outra forma de encadear funções ==

Objetivos:

Perceber que a composição de muitas funções pode tornar a leitura do código muito complicada e saber aplicar o conceito de _Threading first_ para compor funções de uma forma mais simples.

- Perceber as situações onde a legibilidade do código fica comprometida pelo volume de composições de chamadas de muitas funções.
- Ser capaz de executar composição de funções usando _Threading first_.

== Parte 9: Calculo IMC ==

Objetivos:

Ser capaz de acompanhar o desenvolvimento de um software simples utilizando as técnicos como TDD e REPL Driven Development.

[[Exemplo IMC com Clojure]]
- Conhecer um código de uma funcionalidade real e criada usando TDD e REPL driven development.

== Parte 10: Funções públicas e privadas ==

Objetivos:

Aprender noções de boas práticas de visibilidade das funções e compreender quando uma funções deve ser definida como pública e quando pode ser privada.

- Entender os potencias problemas de deixar todas as funções como públicas.
- Aprender a criar funções privadas.

== Parte 11: Mais sobre maps, map, filter e reduce: Loja de brinquedos ==

Objetivos:

Ser capaz de acompanhar o desenvolvimento de um outro software explorando mais o uso de estrutura de dados mapa e as funções _map_, _filter_ e _reduce_.

[[Exemplo Calculo preço total da compra em uma loja de brinquedos]]
- Conhecer outro exemplo mais próximo do real: dado uma estrutura de dados com os brinquedos que estamos comprando, queremos calcular o preço total da compra.
- Praticar mais o uso de Threading, trabalhar com mapas e utilizar o filter, map e reduce.

== Parte 12: Conclusões ==

Objetivos:

Conhecer os possíveis caminhos para continuar os estudos da linguagem Clojure e do Paradigma Funcional.

- Conhecer e ser capaz de procurar informações no clojuredocs.org
- Conhecer livros onde pode dar continuidade de seus estudos.

= Sobre o autor =

Meu nome é Marcio Frayze David e sou autor deste curso.
  
Desenvolvo softwares há mais de uma década. Desde 2009 trabalho como
analista de sistemas no Serviço Federal de Processamento de Dados
(SERPRO), onde ajudo diversas equipes a
implementar soluções para clientes como a Receita Federal do Brasil e
o Departamento Nacional de Trânsito (DENATRAN). Nesta empresa atuei
em muitas soluções, incluindo o desenvolvimento do aplicativo
Carteira Digital de Trânsito (CDT).  
Embora durante a maior parte do meu trabalho passe desenvolvendo softwares
no *backend*, também desenvolvo *frontends* e aplicativos móveis (para iOS e
Android).

Você pode conhecer mais sobre mim em: https://segunda.tech/sobre
