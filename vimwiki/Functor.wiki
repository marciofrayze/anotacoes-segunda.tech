= _Functor_ =

refs:
* [[Livro Learn You a Haskell for Great Good!]]
  * Capítulo 8: Making Our Own Types and Typeclasses
    * http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass
  * Capítulo 11: Functors, Applicative Functors and Monoids
    * http://learnyouahaskell.com/functors-applicative-functors-and-monoids
* Site Wiki Haskell
  * https://wiki.haskell.org/Functor
* Site Haskell.org
  * https://www.haskell.org/tutorial/numbers.html
  
== Definição ==

Em [[Haskell]], um _Functor_ representa uma [[Typeclass]] capaz de 
realizar uma transformação, e é definida por:

{{{Haskell
class Functor f where  
    fmap :: (a -> b) -> f a -> f b  
}}}

_*fmap*_ é uma [[Função de primeira ordem|função de primeira ordem]] e
*_(a -> b)_* representa a função de transformação que será
aplicada à cada elemento de *_f a_* e o
resultado final será um novo _Functor_, representado
por *_f b_*.

A primeira linha deste código indica que será
possível executar a função _*fmap*_ em qualquer tipo que
seja uma instância de _Functor_.

Lembrando que em Haskell, _*Class*_ tem um
significado diferente do usado na orientação a objetos.
Para mais informações, leia sobre [[Typeclass|o que é uma Typeclass]].

== Exemplos ==

Um exemplo clássico de _Functor_ são as Listas.

Podemos fazer um *_fmap_* em uma lista, executando uma
função de transformação para cada elemento. Como
resultado temos uma lista de mesmo tamanho, mas
podendo conter elementos de algum outro tipo ou
do mesmo tipo mas com outros valores, ou até mesmo
uma lista igual à inicial.

Como toda [[Função de primeira ordem|função de primeira ordem]],
a função que passamos como parâmetro para o *_fmap_* pode
ser nomeada (que tenha sido declarada anteriormente) ou uma 
expressão lambda ([[Lambda expression]]).

=== Utilizando _*fmap*_ com uma expressão lambda ===

Se quisermos somar 1 à todos os elementos de uma lista
de números, podemos escrever o seguinte código em Haskell:

{{{haskell
fmap (\n -> n + 1) [1, 2, 3, 4] 
}}}

Para definirmos uma expressão lambda nesta linguagem, 
usamos o caractere *\* (que lembra um pouco o símbolo lambda: λ).

No trecho *_(_\_n -> n + 1)_*, estamos definindo uma expressão
lambda que receberá como parâmetro um número _*n*_ e irá
retornar *_n + 1_*. Esta função será executada para
cada elemento da lista e uma nova lista será criada
com o resultado dessas execuções.

Desta forma o resultado deste *_fmap*_ será:

{{{haskell
[2, 3, 4, 5]
}}}

Voltando para definição, neste exemplo:

- *_f_* é um _Functor_ do tipo Lista, que em Haskell é representando pelo símbolo *[]*.  
- *_a_* é um *_Num_*, representando o tipo dos elementos contidos na lista de entrada.  
- *_b_* também é um *_Num_*, representando o tipo dos elementos da lista que será retornada.  
- *_(a -> b)_* é uma função de transformação, que irá receber um elemento do tipo *_a_* e retornar um elemento do tipo *_b_*. Neste caso, irá receber um número *_a*_ e retornar um outro número *_b_*.
  
Em Haskell, *_Num_* é uma _Typeclass_ que representa os tipos
numéricos.

Neste exemplo *_a_* e *_b_* são da mesma classe, mas
poderíamos ter como resultado uma lista com elementos
de outra classe.

Se quiséssemos por exemplo transformar uma lista de números
em uma lista de Strings (que no Haskell é representado por um
[[array]] de char), poderíamos escrever o seguinte código:

{{{haskell
fmap (\n -> show n) [10, 11, 12, 13] 
}}}

Onde [[show]] é uma função capaz de transformar um número em
um array de caracteres. 

Em nosso código acima, *_fmap_* irá primeiro executar a
função _*show*_ passando o primeiro elemento da lista
como parâmetro, que irá retornar o valor "1". 
Em seguida irá percorrer os demais elementos da lista e,
um por um, irá executar a função _*show*_, passando um
elemento da lista por vez. Conforme esta operação é feita
o resultado de cada executação é armazenado em uma nova lista.

Após percorrer por todos os elementos e terminar
de criar a lista com o resultado de todas as
operações, *_fmap_* irá retornar a nova lista:

{{{haskell
["10", "11", "12", "13"]
}}}

Dizemos que *_fmap_* é uma função de *transformação*. Mas, embora
seja possível mudar o tipo dos elementos contidos dentro do
_Functor_ (neste caso, a Lista) através do _*fmap*_, não é
possível mudarmos o tipo do _Functor_ nem seu tamanho.
Ou seja, dada uma lista com 4 elementos, o _*fmap*_ sempre
retornará uma lista contendo 4 elementos.

Voltando mais uma vez para definição:

{{{Haskell
class Functor f where  
    fmap :: (a -> b) -> f a -> f b  
}}}

Note que a entrada é *_f a_* e a saída é *_f b_*. Ou seja,
o tipo do _Functor_, representado pela letra
*_f_*, é obrigatórimente o mesmo.

=== Utilizando _*fmap*_ com uma função nomeada (_named function_) ===

Podemos utilizar uma função já existente e passa-lá como
parâmetro para o _*fmap*_.

No exemplo abaixo definimos uma função chamada _soma1_ e em seguida 
a passamos como parâmetro para o *_fmap_*:

{{{haskell
soma1 n = n + 1

fmap soma1 [1, 2, 3, 4] 
}}}

E o resultado será igual ao obtido quando utilizamos uma
expressão lambda:
{{{haskell
[2, 3, 4, 5]
}}}

Este mecânismo é útil em 2 situações:
- Quando a função é muito complexa, para facilitar o entendimento do código ou;
- Quando querermos re-aproveitar uma função pré-existente.

== Outros Functors ==

É comum usarmos listas para exemplificar o uso do _*fmap*_, mas
existem vários outros tipos e podemos até mesmo
instanciar nossos próprios _Functors_!

Outros _Functors_ famosos incluem o [[Maybe]] (conhecido também como _Optional_
em algumas linguagens) e o [[Either]]. Mas este exemplos vão ficar para
um outro artigo.

== Conclusão ==

O que foi discutido aqui é apenas uma introdução ao assunto.
Para aprender mais sobre este e outro temas da Programação Funcional, recomendo
o excelente (e gratuito) livro [[Livro Learn You a Haskell for Great Good!]].
