= _Functor_ =

refs:
* [[Livro Learn You a Haskell for Great Good!]]
  * Capítulo 8: Making Our Own Types and Typeclasses
    * http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass
  * Capítulo 11: Functors, Applicative Functors and Monoids
    * http://learnyouahaskell.com/functors-applicative-functors-and-monoids
* Site Wiki Haskell
  * https://wiki.haskell.org/Functor
  
== Definição ==

Em [[Haskell]], um _Functor_ representa uma [[Typeclass]] capaz de 
realizar uma transformação, e é definida por:

{{{Haskell
class Functor f where  
    fmap :: (a -> b) -> f a -> f b  
}}}

Onde *_(a -> b)_* é uma função de transformação que será
aplicada à cada elemento do _Functor_ *_f a_* e o
resultado final será um novo _Functor_, representado
por *_f b_*.

Lembrando que em Haskell _*Class*_ tem um
significado bem diferente do usado na orientação a objetos.
Para mais informações, leia sobre [[Typeclass|o que é uma Typeclass]].

== Exemplos ==

Um exemplo clássico de _Functor_ são as Listas.

Podemos fazer um *_fmap_* em uma lista, executando uma
função de transformação para cada elemento. Como
resultado temos uma lista de mesmo tamanho, mas
podendo conter elementos de algum outro tipo ou
do mesmo tipo mas com outros valores, ou até mesmo
uma lista igual à inicial.

O primeiro parâmetro de _*fmap*_ pode ser uma função
nomeada (declarada anteriormente) ou uma [[Lambda expression]].

=== Utilizando _*fmap*_ com uma expressão lambda (_lambda expression_) ===

Se quisermos somar 1 à todos os elementos de uma lista
de números, podemos escrever o seguinte código em Haskell:

{{{haskell
fmap (\n -> n + 1) [1, 2, 3, 4] 
}}}

No trecho *_(\n -> n + 1)_*, estamos definindo uma expressão
lambda que receberá como parametro um número _*n*_ e irá
retornar *_n + 1_*. Esta função será executada para
cada elemento da lista e uma nova lista será criada
com o resultado dessas execuções.  

Desta forma o resultado do *_fmap*_ será:

{{{haskell
[2, 3, 4, 5]
}}}

Neste exemplo mantivemos o mesmo tipo de elemento, mas
poderíamos ter como resultado uma lista com outro tipo.

Se quiséssemos por exemplo transformar uma lista de números
em uma lista de Strings ou, no caso do Haskell, um array
de char, poderíamos escrever o seguinte código:

{{{haskell
fmap (\n -> show n) [1, 2, 3, 4] 
}}}

Onde [[show]] é uma função do Haskell capaz de transformar
um número em um array de caracteres. 

Em nosso código acima, *_fmap_* irá primeiro executar a
função _*show*_ passando o primeiro elemento da lista
como parâmetro, que irá retornar o valor "1". 
Em seguida irá percorrer os demais elementos da lista e,
um por um, irá executar a função _*show*_, passando um
elemento da lista por vez. Conforme esta operação é feita
o resultado de cada executação é armazenado em uma nova lista.

Após percorrer por todos os elementos e terminar
de criar a lista com o resultado de todas as
operações, *_fmap_* irá retornar a nova lista:

{{{haskell
["1", "2, "3", "4"]
}}}

Por isso dizemos que *_fmap_* é uma função de *transformação*.

Mas embora seja possível mudar o tipo dos elementos
contidos dentro do _Functor_ (neste caso, a Lista) através
do _*fmap*_, não é possível mudarmos o tamanho do _Functor_. Ou
seja, dada uma lista com 4 elementos, o _*fmap*_ sempre
retornará uma lista contendo 4 elementos.

=== Utilizando _*fmap*_ com uma função nomeada (_named function_) ===

Podemos utilizar uma função já existente e passa-lá como
parâmetro para o _*fmap*_. Por exemplo:

{{{haskell
soma1 n = n + 1

fmap soma1 [1, 2, 3, 4] 
}}}

E o resultado será igual ao obtido quando utilizamos uma
expressão lambda:
{{{haskell
[2, 3, 4, 5]
}}}

Este mecânismo é útil em 2 situações:
- Quando a função é muito complexa, para facilitar o entendimento do código ou;
- Quando querermos re-aproveitar uma função pré-existente.

=== Outros Functors ===

É comum usarmos listas para exemplificarmos o uso do _*fmap*_, mas
existem vários outros tipos de _Functors_ e podemos até mesmo
criar nossos próprios _Functors_!

(...)
